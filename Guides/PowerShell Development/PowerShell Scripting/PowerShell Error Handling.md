# Error Handling

- **Exception**: 
	- An exception is like an event that is created when normal error handling cannot deal with the issue. 
	- Trying to divide a number by zero or running out of memory are examples of something that creates an exception. 
	- Sometimes to code's author creates exceptions for certain issues when they happen.
- **Throw** and **Catch**: 
	- When an exception occurs, we say that an *exception is thrown*. 
	- To handle a thrown exception, you need to *catch* it. 
	- If an exception is thrown and it is not caught by something, the script stops executing.
- The **Call Stack**: 
	- The call stack is the list of functions that have called each other. 
	- When a function is called, it gets added to the stack or the top of the list. 
	- When the function exits or returns, it is removed from the stack. 
	- When an exception is thrown, that call stack is checked in order for an exception handler to catch it.
	- `Write-Error` and other non-terminating errors do not trigger the `catch`.
- **Terminating** and **Non-Terminating** Errors: 
	- **Terminating**: A terminating error is a fatal mistake which will halt the execution of the program.
	- **Non-Terminating**: A non-terminating error is less serious and will not result in halting the execution of the program.
	- An exception is generally a terminating error. 
	- A thrown exception is either caught or it terminates the current execution. 
	- By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.
- **Swallowing** an Exception:
	- This is when you catch an error just to suppress it. Do this with caution because it can make troubleshooting issues very difficult.

If [[PowerShell]] encounters a *non-terminating error*, it first checks the value of the`ErrorActionPreference` variable to determine if it should continue or terminate the execution. By default, this value is set to `Continue` which means that if [[PowerShell]] encounters an error then it should just continue processing the rest of the script.

If instead you desire to terminate the code as soon as an error is encountered, modify the `ErrorActionPreference`, but keep in mind that this is a *Global Variable* and will impact all other code also. As a best practice, it is best to 

### Throw and Write-Error

```powershell
# throw an exception using the 'throw' keyword:
Function Start-Something {
	Throw "Uh Oh"
}

# The function above creates a runtime exception that corresponds to a "terminating" error
# It's handled by a `catch` in a calling function or exits the script with the message "Uh Oh"

Start-Something

# To write an error to the error stream and throw a terminating error to be handled with catch you have to add `-ErrorAction Stop` to `Write-Error`

Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

### Try-Catch

The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it. Here is a quick sample.

```powershell
Try {
	Start-Something
}
Catch {
	Write-Output "Something threw an exception"
	Write-Output $__
}

Try {
	Start-Something -ErrorAction Stop
}
Catch {
	Write-Output "Something threw an exception or used Write-Error"
	Write-Output $_
}
```

The `catch` script only runs if there's a terminating error. If the `try` executes correctly, then it skips over the `catch`. You can access the exception information in the `catch` block using the `$_` variable.

#### Try-Finally

Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not. A `finally` script does exactly that.

Take a look at this example:

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

Anytime you open or connect to a resource, you should close it. If the `ExecuteNonQuery()` throws an exception, the connection isn't closed. Here is the same code inside a `try/finally` block.

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
Try {
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
Finally {
    $command.Connection.Close()
}
```

In this example, the connection is closed if there's an error. It also is closed if there's no error. The `finally` script runs every time.

Because you're not catching the exception, it still gets propagated up the call stack.

#### Try-Catch-Finally

It's perfectly valid to use `catch` and `finally` together. 

Most of the time you'll use one or the other, but you may find scenarios where you use both.

### `$PSItem`

Now that we got the basics out of the way, we can dig a little deeper.

Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception. Here is a quick overview of some of the key properties.

For these examples, I used an invalid path in `ReadAllText` to generate this exception.

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

#### `$PSItem.ToString()`

This gives you the cleanest message to use in logging and general output. `ToString()` is automatically called if `$PSItem` is placed inside a string.

```powershell
Catch {
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}
Catch {
    Write-Output "Ran into an issue: $PSItem"
}
```

#### `$PSItem.InvocationInfo`

This property contains additional information collected by PowerShell about the function or script where the exception was thrown. Here is the `InvocationInfo` from the sample exception that I created.

```powershell
$PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.
